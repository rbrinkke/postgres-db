rchitectuurvoorstel: High-Performance Decoupled ACLStatus: VoorstelDoel: Latency van de Chat Service elimineren, business-logic ontkoppelen en 100% dataconsistentie garanderen.1. ProbleemstellingDe huidige Chat Service is tightly coupled met domein-logica. Om permissies te valideren ("Mag User X in Chat Y?") zijn dure runtime JOINs nodig over verschillende services (Activity, Friends, Calendar). Dit resulteert in:Hoge Read-Latency: Query-tijd schaalt lineair/exponentieel met data-groei.Circulaire afhankelijkheden: De Chat Service breekt als regels in de Activity Service wijzigen.2. Oplossing: Materialized ACL met Bitmasking & TriggersWe implementeren het Access Control List (ACL) patroon. We verplaatsen de autorisatie-complexiteit van Read-Time naar Write-Time. De berekende rechten worden gematerialiseerd in een centrale tabel. Om te voorkomen dat deze tabel uit de pas loopt met de werkelijkheid (synchronisatie-fouten), gebruiken we Database Triggers.2.1 DatastructuurWe gebruiken een platte tabel in de Auth Service (of shared schema). Voor maximale performance en toekomstbestendigheid gebruiken we 64-bit Integer Bitmasking in plaats van text-arrays of JSON.Tabel: auth.resource_accessKolomTypeBeschrijvingresource_idUUIDID van de Chat, Activiteit of File.user_idUUIDID van de gebruiker.serviceVARCHARContext (Namespace). Bijv: 'activity', 'private_chat', 'system'. Noodzakelijk voor beheer en scoping.permission_maskBIGINTBitmask (64-bit). Biedt ruimte voor 63 unieke permissies, wat voldoende groei biedt voor complexe rollen in de toekomst.Bitmask Definitie (Basis):1 (Binair ...001) = READ2 (Binair ...010) = WRITE4 (Binair ...100) = ADMIN/DELETEVoorbeeld: Iemand met Read+Write rechten krijgt waarde 3 (1+2).2.2 Architecturale FlowA. Write Path (Mutatie via Triggers)De business services (Activity/Social) blijven eigenaar van de logica en schrijven naar hun eigen tabellen (bijv. organization_members).Mechanisme: We plaatsen een Database Trigger op de bron-tabellen.Werking: Zodra een record wordt toegevoegd, gewijzigd of verwijderd in de bron, vuurt de trigger direct in dezelfde transactie.Logica: De trigger vertaalt de functionele rol (bijv. "Penningmeester" of "Admin") direct naar de technische bitmask en werkt de auth.resource_access tabel bij.Garantie: Doordat dit in één database-transactie gebeurt, is het onmogelijk dat iemand wel lid is, maar geen rechten heeft (ACID compliant).B. Read Path (Validatie)De Chat Service voert geen business logica meer uit en doet geen dure joins. De check is puur technisch.Query:SQL-- Check: Heeft User schrijfrechten (Bit 2)?
SELECT 1 FROM auth.resource_access 
WHERE resource_id = ? 
  AND user_id = ? 
  AND (permission_mask & 2) > 0;
3. VoordelenExtreme Performance: De check is een O(1) operatie op een primary key met een simpele integer vergelijking. Sneller bestaat niet in een RDBMS.Decoupling: De Chat Service is agnostisch. Het maakt technisch niet uit of het een 1-op-1 chat, een groepsactiviteit of een bestand is; de logica is identiek.Data Consistentie: Door het gebruik van triggers is er geen race condition mogelijk tussen de applicatie en de database. De ACL-tabel is altijd actueel.Schaalbaarheid & Flexibiliteit: Door te kiezen voor BIGINT (64-bit) in plaats van INT (32-bit) voorkomen we toekomstige migraties als de applicatie complexere permissie-structuren nodig heeft.4. Implementatie StrategieAanmaken auth.resource_access tabel (Composite PK op resource_id + user_id) met indexen geoptimaliseerd voor de lookup query.Triggers implementeren: We schrijven database-functies die gekoppeld worden aan de INSERT, UPDATE en DELETE events op de organization_members tabellen. Deze functies bevatten de vertaal-logica van Rol naar Bitmask.Chat Service refactoren om de nieuwe SELECT check te gebruiken in plaats van de huidige API calls.Eenmalig migratie-script draaien om bestaande rechten te vullen in de nieuwe tabel.
